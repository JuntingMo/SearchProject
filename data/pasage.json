{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1675756953717968897",
        "title": "这些代码，差点把我气出内伤",
        "description": null,
        "content": "大家好，我是鱼皮，一个正在烂代码的泥潭里面摸爬滚打的程序员。\n\n先问大家一个小问题：你觉得看别人代码累，还是自己写代码累？\n\n我相信有很多朋友会说，当然是自己写代码累了，要思考逻辑、要动手敲键盘，身心俱疲啊；但是，如果你需要经常阅读别人的代码，尤其是烂代码，答案就不一定了。\n\n因为自己写代码，逻辑是自己来梳理的、代码自己是熟悉的；但是看别人的代码，你就要去理解别人的代码逻辑，再加上烂代码的加持，可能很简单的逻辑，你都得看半天才能懂。所以很多大佬在面对前人的 “屎山” 项目时，宁愿自己重写，也不去读烂代码。\n\n举个夸张的例子：让你实现 1 + 1 的求和\n\n自己写：\n\n```javascript\nlet sum = 1 + 1;\n```\n\n某烂代码可能是：\n\n```javascript\nlet a = {};\nlet b = {};\n\na.toString = function() {\n  return 1;\n};\n\nb.valueOf = function() {\n  return \"1\";\n};\n\nlet sum = a + b;\n```\n\n把简单的逻辑搞复杂，便是绝大多数程序员的拿手好戏（当然也包括我）。\n\n因为我从大学就开始带团队做项目了嘛，所以经常会审查团队同学的代码，做好二次校验。包括现在虽然开公司了，前端 / 后端同学的代码，也都会在我这过一遍才会发布上线。\n\n总之算是看了很多代码，其中有一些真的是让我哭笑不得。下面给大家分享一些代码片段出来，希望大家 **不要学习** 。\n\n\n\n#### 1、过于抽象的命名\n\n还记得咱们刚学编程的时候，变量的命名都是用的 abcdefg。\n\n自学时这么写完全没问题，但是在实际项目中，如果还用过于抽象的命名，那就不太合适了。\n\n比如下面这段，大家能看懂是什么意思么？\n\n```js\nconst [l, setL] = useState<boolean>(false);\nconst [d, setD] = useState<any>();\n```\n\n但如果我稍微完善下命名呢：\n\n```js\nconst [loading, setLoading] = useState<boolean>(false);\nconst [data, setData] = useState<any>();\n```\n\n很多同学应该立刻能看懂了，一个是 “加载中” 的变量，一个是 “存储数据” 的变量。\n\n最好的代码应该是不用写注释的，因为 **代码即注释** 。如果你能把命名做到 “见名知义”，看代码的人会极度舒适。\n\n\n\n#### 2、有深度的代码\n\n比如下面这段：\n\n```javascript\nif (condition1) {\n  // 逻辑 A\n  if (condition2) {\n    // 逻辑 B\n    if (condition3) {\n      // 逻辑 C\n      if (condition4) {\n        // 逻辑 D\n      }\n    }\n  }\n}\n```\n\n这里的深度有 2 重含义，一重是字面意思：代码一层嵌一层、深不见底；另外一重是指真的 “很有深度” —— 指让人看不懂。\n\n阅读这段代码的感觉就像是你在一座巨大的迷宫里，每次转弯都要判断下是左还是右，最后你只会迷失方向。\n\n如何改进呢？\n\n最简单直接的方法就是使用早返回策略（early return）：\n\n```javascript\nif (!condition1) \n\t// 逻辑 A\n\treturn;\nif (!condition2)\n  // 逻辑 B\n\treturn;\nif (!condition3)\n  // 逻辑 C\n\treturn;\nif (!condition4)\n  // 逻辑 D\n\treturn;\n```\n\n这样，你的代码就清晰了很多，阅读这种代码的感觉就像是走在了一条直路上，前方的路一目了然。\n\n当然，还可以将一些逻辑抽象成独立函数来简化代码，或者使用设计模式来优化。\n\n怎么判断一段代码是否过于复杂、应该优化了呢？这里提到一个概念： **圈复杂度** ，这是一种量化代码复杂程度的概念。通常你代码中的 if else 分支越多，圈复杂度就越高，代码就越复杂。\n\n企业中一般建议圈复杂度不要超过 10 - 15，我个人的编码习惯是一般不会在代码中出现 3 层以上的嵌套（除非必要）。\n\n\n\n#### 3、冗余代码\n\n这是我遇到最多的问题！分为 3 种情况：\n\n1. 能用一行代码搞定，偏偏要写 10 行\n2. 能用一个变量或函数搞定，偏偏每次都是复制粘贴重复写\n3. 没有用到的代码，又不舍得删除\n\n\n\n举个例子，下面这段前端代码，大家觉得有什么问题：\n\n> 这是我们鱼聪明 AI 前端开发过程的真实代码\n\n```react\n<Spin spinning={!(currDownloadUrl || originPictureUrl || pictureUrl)}>\n  {type === DRAW_APP ? (\n    drawImg(image)\n  ) : (\n    drawImg(currDownloadUrl || originPictureUrl || pictureUrl)\n  )}\n</Spin>\n```\n\n\n\n\n\n第一眼看到这段代码时，我就发现了，判断 spinning（旋转）的代码逻辑比较复杂，包含了两个 `||` 逻辑。而下面的 `drawImg` 函数的参数中，又包含了这段一模一样的逻辑。这段判断，其实就是冗余代码，完全没必要写两遍！\n\n我调整过后的代码如下：\n\n```javascript\n// 要展示的图片地址\nconst showPictureUrl = currDownloadUrl || originPictureUrl || pictureUrl;\n```\n\n直接定义一个通用变量，写上清晰的注释，其他地方要使用时就无需关注内部判断逻辑，看注释就行了。\n\n这就是所谓的 **DRY 原则**（Don't Repeat Yourself） ，尽量避免代码冗余。如果你在多处写下相同的代码，那么当需要修改这段代码时，你就需要在所有这些地方都修改，漏一个地方就是一个 Bug。\n\n还有，关于项目中没有用到的函数和变量，如果你近期没有使用计划，不妨就删除或者注释掉，别舍不得。利用好 Git 版本控制系统，只要你的代码提交信息写得好，要用到被删掉的历史代码时，去提交记录里找即可。\n\n> 注意，如果是学习时写代码，多保留一些也是合理的。但企业项目中，项目代码精简凝练些会更好。\n\n\n\n这里打个比方，写代码就像是我在公司里堆东西，一开始总觉得多一点没关系，反正有空间。但是，冗余代码就像是杂物，会越堆越多，迟早有一天，会影响到你，就像我们公司现在一样（右边有一堆杂物）：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230701171133600.png)\n\n\n\n大概就分享到这里，请大家在评论区 @ 出你写烂代码的同事吧 \uD83D\uDC36 ~\n\n\n\n---\n\n\n\n欢迎学编程的朋友们加入鱼皮的 [编程知识星球](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=292259508&lang=zh_CN#rd) ，和 2 万多名学编程的同学共享知识、交流进步，学习原创项目并享有答疑指导服务。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/H3EBmkIl-640.jpg",
        "language": null,
        "viewNum": 45,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-03T06:42:46.000+00:00",
        "updateTime": "2023-07-03T15:26:03.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1740,
          "coin": 170,
          "followeeNum": 862,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-03T15:46:55.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Javascript",
          "后端",
          "前端"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1675524671698636802",
        "title": "react 新官方文档学习 描述UI",
        "description": "react新官方文档，如何创建UI页面，书写规范的代码",
        "content": "## 描述UI\n\n​\t当你使用 react 开发一段时间后，你会发现，对于前端来说，工作内容，就是把**数据**按照 UI 给定的设计稿通过代码的方法描述出来，那么在这里，处理数据（得到能够渲染到页面的数据）和 展示数据 是前端开发两个重中之重的基本功。\n\n​\t对于我来说，我喜欢在拿到 UI 稿后，先把 HTML 骨架搭建好，也就是先实现描述 UI 这一步，然后再去获取数据，处理交互，控制数据流。也就是由易到难进行开发，接下来就一起看看官方文档如何教初学者描述 UI 的吧！\n\n----\n\n**在接下来，我们会探讨如下问题**\n\n1. **如何编写第一个 React 组件**\n2. **何时以及如何创建多组件文件**\n3. **如何使用 JSX 向 JavaScript 添加标记**\n4. **如何在 JSX 中使用花括号来访问组件中的 JavaScript 功能**\n5. **如何用props配置组件**\n6. **如何有条件地呈现组件**\n7. **如何一次渲染多个组件**\n8. **如何通过保持组件的纯净来避免混淆 bug**\n\n-----\n\n​\tReact是一个用于渲染用户界面（UI）的 JavaScript 库。UI 是由按钮、文本和图像等小单元构建的。React允许您将它们组合成可重用的、可嵌套的组件。从网站到手机应用程序，屏幕上的所有内容都可以分解为组件。在本章中，您将学习如何创建、自定义和有条件地显示React组件。\n\n### 你的第一个组件\n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\t**先说重点，react 组件，不仅仅是一种代码组织方式，更是一种 react 编程思维**\n\n​\tReact应用程序是从称为组件的独立UI部分构建的。React组件是一个JavaScript函数，你可以在其中添加标记。组件可以小到一个按钮，也可以大到整个页面。下面是一个 `Gallery` 组件，它是由三个 `Profile ` 组件渲染得到的\n\n```js\n// app.js\nfunction Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/MK3eW3As.jpg\"\n      alt=\"Katherine Johnson\"\n    />\n  );\n}\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}\n```\n\n你会在页面看到：\n\n![image-20230701221658409](C:\\Users\\30749\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230701221658409.png)\n\n#### 1. 组件是什么\n\n组件是：UI构建块\n\n​\t在前端，HTML让我们可以使用内置的标签集（如 `<h1>` 和 `<li>` ）创建丰富的结构化文档。如：\n\n```html\n<article>\n  <h1>My First Component</h1>\n  <ol>\n    <li>Components: UI Building Blocks</li>\n    <li>Defining a Component</li>\n    <li>Using a Component</li>\n  </ol>\n</article>\n```\n\n​\t这个标记代表这篇文章 `<article>` ，它的标题 `<h1>` ，以及一个（缩写）目录作为有序列表 `<ol>` 。像这样的标记，结合用于样式的 CSS 和用于交互性的 JavaScript，构成了 Web 上每个侧边栏、头像、模态框、下拉菜单等 UI 元素的基础。但是我想要**复用** 这个 article 组件，要怎么办呢？现在我们可以通过 react 来实现这个文章组件的复用\n\n​\tReact允许您将标记、CSS和 JavaScript 组合成自定义的“**组件**”，用于您的应用程序的可重用UI元素。您在上面看到的目录代码可以转换为一个 `<TableOfContents />` 组件，您可以在每个页面上呈现。在底层，它仍然使用相同的HTML标签，如 `<article>` ， `<h1>` 等。\n\n​\t随着项目的发展，您会注意到许多设计可以通过重用您已经编写的组件来组合，从而加快开发速度。我们上面的目录可以添加到任何屏幕上，使用 `<TableOfContents />` ！您甚至可以使用React开源社区共享的成千上万个组件来快速启动项目，例如Chakra UI和Material UI。这个在你使用 ant design 组件库的时候最为明显，它封装了一些通用的组件库，我们仅仅按照官方文档的要求使用即可，不需要操心任何事情\n\n#### 2. 组件在React应用中扮演的角色是什么\n\n​\t在 react 应用中，组件就像是构建应用的 “砖块”，我们可以通过不同的“砖块”（组件），快速搭建我们 react ”房子“（应用），\n\n#### 3. 如何编写你的第一个React组件\n\n**React组件是一个JavaScript函数**，这个函数返回一个 JSX 标记，可以渲染在页面上，当然，我们可以在函数中写一个这个组件的通用逻辑，例如：如何处理交互，创建一个新的组件，你应该做下面几个事情\n\n1. 导出函数\n2. 定义函数\n3. 添加标记\n\n举个例子\n\n```js\nexport default function Profile() { // 使用 export default 导出函数 Profile 定义函数\n  return ( // return一个只有一个跟标签的 html 集合，来添加标记\n    <section>\n      <Title>124</Title>\n    \t<img\n      \tsrc=\"https://i.imgur.com/MK3eW3As.jpg\"\n      \talt=\"Katherine Johnson\"\n    \t/>\n   \t</section>\n  );\n}\n```\n\n#### 4. 深入探索\n\n​\t您的React应用程序从一个“根”组件开始。通常，在启动新项目时会自动创建它。例如，如果您使用 `CodeSandbox` 或 `Create React App`，根组件在 `src/App.js` 中定义。如果您使用Next.js框架，则根组件在 `pages/index.js` 中定义。在这些示例中，您已经导出了**根组件**。细心的同学发现，react 创建的应用就是一个单文件应用（它仅仅有一个HTML文件），它的所有内容都在根组件中，都绑定在 id 为 #app 的根元素上，它里面包含了所有的子组件\n\n​\t大多数 React 应用程序都使用组件。这意味着您不仅会将组件用于可重用的部分，例如按钮，还会将其用于更大的部分，例如侧边栏、列表，甚至是完整的页面！组件是一种方便的方式来组织 UI 代码和标记，即使其中一些组件只使用一次。\n\n​\t基于React的框架将这一步进一步。它们不再使用空的 HTML 文件并让 React 通过 JavaScript “接管”页面的管理，而是还会自动从 React 组件中生成 HTML 。这使得您的应用在 JavaScript 代码加载之前就能显示一些内容。\n\n​\t然而，许多网站仅使用 React 来为现有的 HTML 页面添加交互性。它们有许多根组件，而不是一个用于整个页面。您可以根据需要使用多少或少量的 React。也就是说，你可以在你的项目指定地方使用 react\n\n⭕️注意：\n\n1.  **没有括号， `return` 之后的任何代码都将被忽略！**\n\n2. **大小写的区别，** section 小写，react 知道这是一个 HTML 标签，Title 大写 react 也就知道这是一个 React 组件\n3. **每一个组件，都应该是一个单文件**，不可以在一个组件中，再声明另一个组件，这样会产生很多问题，例如：作用域混乱\n\n```js\n// 组件可以渲染其他组件，但是你绝不能嵌套它们的定义：\n// ❌\nexport default function Gallery() {\n  // \uD83D\uDD34 Never define a component inside another component!\n  function Profile() {\n    // ...\n  }\n  // ...\n}\n// ✅ 但是更加推荐，一个组件，就放在一个文件中\nexport default function Gallery() {\n  // ...\n}\n\n// ✅ Declare components at the top level\nfunction Profile() {\n  // ...\n}\n```\n\n最后总结以下关键点\n\n- React 允许您创建组件，可重复使用的应用程序UI元素。\n- 在 React 应用中，每个 UI 都是一个组件。\n- React 组件是常规的 JavaScript 函数，但是：\n  - 他们的名字总是以大写字母开头。\n  - 它们返回 JSX 标记。\n\n### 导入和导出组件\n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\t当我们一个项目，组件越来越多时候，把每个组件抽离为一个单文件，是有利于代码维护和组件复用，所以我们使用导入导出来实现组件的复用\n\n​\t您可以在一个文件中声明多个组件，但这里的缺点是**组件太多**可能会很难导航（因为一个文件代码太多会很乱）。要解决此问题，可以将组件导出到其他的文件中，然后从另一个文件导入该组件\n\n​\t\n\n```js\n// Profile.js\nexport default function Profile() {\n  return (\n    <img\n      src=\"https://i.imgur.com/QIrZWGIs.jpg\"\n      alt=\"Alan L. Hart\"\n    />\n  );\n}\n```\n\n```js\n// Gallery.js\nimport Profile from './Profile.js';\n\nexport default function Gallery() {\n  return (\n    <section>\n      <h1>Amazing scientists</h1>\n      <Profile />\n      <Profile />\n      <Profile />\n    </section>\n  );\n}\n```\n\n这里我们通过 import  和 export 的形式，实现了一个组件一个文件，在复杂组件的情况，逻辑依然清晰明了\n\n#### 1. 根组件文件是什么\n\n​\t当前位于根组件文件中，例如在此示例中命名为 `App.js` 。在 Create React App 中，您的应用程序位于 `src/App.js` 。根据您的设置，您的根组件可能位于另一个文件中。如果您使用基于文件的路由的框架，例如Next.js，每个页面的根组件将不同。\n\n#### 2. 如何导入和导出一个组件\n\n​\t当我们想要根文件不放任何组件逻辑，我们就需要把根组件都移出，这样我们就需要 import 和 export ，我们应该这么做\n\n1.  创建一个新的JS文件来放置组件。\n2.  **export** 从该文件中导出您的函数组件（使用默认导出或命名导出）。\n3.  **import** 将其导入到将使用该组件的文件中（使用相应的默认导入或命名导出技术）。\n\n#### 3. 何时使用默认和命名的导入和导出\n\n⭕️注意：这里导出，我们即可使用 export default 这样默认导出（这里就只能有一个 export default ），也可以 export 一个变量（这里可以有多个 export ），这里是 JavaScript 的 ES6 modules 具体详情可点击：[Module 语法](https://es6.ruanyifeng.com/#docs/module)\n\n![image-20230702134216899](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230702134216899.png)\n\n⭕️注意：导出组件的方式决定了你必须如何导入它。如果你尝试以相同的方式导入默认导出，你将会收到一个错误！这个图表可以帮助你跟踪如果文件只导出一个组件，人们通常使用默认导出；如果文件导出多个组件和值，人们通常使用命名导出。无论你偏好哪种编码风格，都要给你的组件函数和包含它们的文件赋予有意义的名称。不推荐使用没有名称的组件，例如 `export default () => {}` ，因为这会增加调试的难度。\n\n#### 4. 如何从一个文件中导入和导出多个组件\n\n在一个文件中写多个组件，然后导出对象的格式，导出多个对象的key的value就是我们的组件\n\n#### 5. 如何将组件拆分为多个文件\n\n也就是把一个组件再拆分为多个组件\n\n最后总结一下关键点\n\n1. 根组件就是 react 项目的入口文件下的组件，例如：app.js 中导出的组件\n2. 通过导入导出组件来实现组件的复用\n3. 可以使用默认导出和命名导出，当只需要导出一个组件的时候，使用默认，导出多个的时候，使用命名导出\n\n### 使用 JSX 编写标记\n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\t每个 React 组件都是一个 JavaScript 函数，其中可能包含一些React渲染到浏览器中的标记。React 组件使用一个名为JSX的语法扩展来表示该标记。JSX 看起来很像 HTML，但它有点严格，可以显示动态信息。\n\n​\t如果我们将现有的HTML标记粘贴到React组件中，它并不总是有效，例如：当你 return 多个跟元素，它就会报错，因为 JSX 语法规定跟组件只能有一个，原因，我在上一篇写 [React 初级开发常见错误](https://mp.weixin.qq.com/s/39twxTGopHatpB6ZUW6aCA)有写\n\n⭕️注意： **JSX**和 React 是两个独立的东西。它们经常一起使用，但你也可以独立使用它们。JSX 是一种语法扩展，而 React 是一个 JavaScript 库。\n\n#### JSX的规则\n\n1. 返回一个根元素，如果需要返回多个元素，请使用 `<></>` 将其包裹起来\n2. 关闭所有标签，也就是任何标签都应该是关闭的 例如 `<img />`\n3.  骆驼命名法几乎所有的东西 例如：` className`  **由于历史原因， `aria-*` 和 `data-*` 属性在 HTML 中以破折号的形式书写。**\n\n总结一下：\n\n1. React 组件将渲染逻辑与标记组合在一起，因为它们是相关的。\n2. JSX 与 HTML 类似，但有一些区别。如果需要，您可以使用转换器。\n3. 错误消息通常会指导您修复标记。\n\n### JSX中带花括号的 JavaScript\n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\t它就像是给HTML 赋予了超能力，让 HTML 可以动态展示信息，\n\n​\tJSX允许您在 JavaScript 文件中编写类似 HTML 的标记，将呈现逻辑和内容保持在同一位置。有时候，您可能希望在标记中添加一些 JavaScript 逻辑或引用一个动态属性。在这种情况下，您可以在JSX中使用花括号来“打开一个窗口”到 JavaScript：\n\n1. 传递带引号的字符串，例如：给 `img` 标签一个动态图片地址 `<img src={picture} />` ，这里picture 就是`img`的地址\n2. 使用花括号：进入JavaScript世界的窗口，例如：我们如果想要在HTML中写一个三元表达式，我们就可以使用`{  }` ，其中任何 JavaScript 表达式都可以放在花括号中，包括函数调用，例如：\n\n```js\n// 这里 name就是一个变量，渲染到页面上就是：Gregorio Y. Zara's To Do List\nexport default function TodoList() {\n  const name = 'Gregorio Y. Zara';\n  return (\n    <h1>{name}'s To Do List</h1>\n  );\n}\n```\n\n3. 只能在这两个地方使用 花括号，1. 作为JSX标签内的文本，如上， 2. 作为紧跟在 `=` 标记后的属性\n4. 使用“双大括号”：在JSX中使用CSS和其他对象，例如 CSS 的`style={{\n         backgroundColor: 'black',\n         color: 'pink'\n       }}` 和 属性的 `person={{ name: \"Hedy Lamarr\", inventions: 5 }}` \n5. 将多个表达式移入一个对象中，并在JSX中使用花括号引用它们，例如：\n\n```js\n// 这里就是在花括号中使用 person 对象，这样也是可以的\nconst person = {\n  name: 'Gregorio Y. Zara',\n  theme: {\n    backgroundColor: 'black',\n    color: 'pink'\n  }\n};\n\nexport default function TodoList() {\n  return (\n    <div style={person.theme}>\n      <h1>{person.name}'s Todos</h1>\n      <img\n        className=\"avatar\"\n        src=\"https://i.imgur.com/7vQD0fPs.jpg\"\n        alt=\"Gregorio Y. Zara\"\n      />\n      <ul>\n        <li>Improve the videophone</li>\n        <li>Prepare aeronautics lectures</li>\n        <li>Work on the alcohol-fuelled engine</li>\n      </ul>\n    </div>\n  );\n}\n```\n\n\n\n### 将props传递给组件\n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\tReact 组件使用 props 来相互通信。每个父组件都可以通过给子组件提供 props 来传递一些信息。Props 可能会让你想起 HTML 属性，但是你可以通过它们传递任何 JavaScript 值，包括对象、数组、函数，甚至 JSX！\n\n详情请看官方文档：https://react.dev/learn/passing-props-to-a-component\n\n### 条件渲染\n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\t您的组件通常需要根据不同的条件显示不同的内容。在React中，您可以使用JavaScript语法（如 `if` 语句、 `&&` 和 `? :` 运算符）有条件地渲染JSX。在本例中，JavaScript `&&` 运算符用于有条件地呈现复选标记：\n\n```js\nfunction Item({ name, isPacked }) {\n    const [isShowLast, setIsShowLast] =  useState(false)\n  return (\n    <li className=\"item\">\n      {name} {isPacked && '✔'}\n    </li>\n  );\n}\n\nexport default function PackingList() {\n  return (\n    <section>\n      <h1>Sally Ride's Packing List</h1>\n      <ul>\n        <Item\n          isPacked={true}\n          name=\"Space suit\"\n        />\n        <Item\n          isPacked={true}\n          name=\"Helmet with a golden leaf\"\n        />\n        {\n         isShowLast ? <Item\n          isPacked={false}\n          \tname=\"Photo of Tam\"\n        \t/>: <></>\n          }\n      </ul>\n    </section>\n  );\n}\n\n```\n\n详细请看：https://react.dev/learn/conditional-rendering\n\n### 渲染列表 \n\n重要程度：\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\uD83C\uDF08\n\n​\t您通常希望显示数据集合中的多个相似组件。你可以使用JavaScript `filter()` 和 `map()` React来过滤和转换你的数据数组为一个组件数组。\n\n​\t对于每个数组项，需要指定一个 `key` （这个是非常重要且必须的）。通常，您会希望使用数据库中的ID作为 `key` 。Keys让React跟踪每个项目在列表中的位置，即使列表发生了变化。\n\n详细请看：https://react.dev/learn/rendering-lists\n\n### 保持 react 组件为纯函数\n\n一些JavaScript函数是纯函数。对于纯函数，它有以下特征：\n\n- **管好自己的事**。它不会更改调用之前存在的任何对象或变量。\n- **同样的输入，同样的输出。**给定相同的输入，纯函数应该总是返回相同的结果。\n\n​    通过严格地只将组件编写为纯函数，您可以在代码库增长时避免整个类的令人困惑的错误和不可预测的行为。这样在遇到 bug 的时候也很好排查问题出现在哪里，这里官方的例子非常的经典\n\n```js\n// 非纯函数\nlet guest = 0;\n\nfunction Cup() {\n  // Bad: changing a preexisting variable!\n  guest = guest + 1;\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup />\n      <Cup />\n      <Cup />\n    </>\n  );\n}\n```\n\n你会看到这个结果：\n\n![image-20230701225325648](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230701225325648.png)\n\n​\t我们看到 同样的`<Cup />` 组件，但是渲染的结果却不相同了，这就是因为它不是一个纯函数导致的，我们可以这样写\n\n```js\nfunction Cup({ guest }) {\n  return <h2>Tea cup for guest #{guest}</h2>;\n}\n\nexport default function TeaSet() {\n  return (\n    <>\n      <Cup guest={1} />\n      <Cup guest={2} />\n      <Cup guest={3} />\n    </>\n  );\n}\n```\n\n![image-20230701225443661](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230701225443661.png)\n\n就可以得到这个结果，这样才是我们想要的效果\n\n详细请看：https://react.dev/learn/keeping-components-pure\n\n​\t如果你都看到这里了，有几个问题考考你\n\n1.  在 JSX 中` 0 && 1` 渲染出来的是什么 \n2.  React 子组件如何接收父组件使用该组件 在标签包含的内容，例如：`<Tag>123</Tag>` 子组件如何获取这个 123\n3. 当我们在 return 中 使用 map 遍历的时候，为什么需要 key \n4. 什么是纯函数？如何保持组件为纯函数？为什么组件为纯函数是一个好事？\n\n​\t这些仅仅是对这些问题的简单总结，详细的回答，还需要我们继续看官方文档更详细的对应模块内容，希望每一个 React 开发者都看一下 dan 大神的[新官方文档](https://react.dev/)，真的很不错，通俗易懂",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/PG1n3JTb-鱼聪明AI绘画.jpg",
        "language": null,
        "viewNum": 13,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-07-02T15:19:46.000+00:00",
        "updateTime": "2023-07-03T11:42:02.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 11,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-07-02T15:18:14.000+00:00"
        },
        "tags": [
          "文章",
          "React"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1673970362427117570",
        "title": "新项目搞完啦！！！",
        "description": null,
        "content": "大家好，我是鱼皮。\n\n经过了 7 场直播，总时长近 20 小时，我在 [自己的编程导航](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=145986907&lang=zh_CN#rd) 的第 5 个 **全程直播开发** 的项目 ——  智能 BI 项目，完结啦！\n\n![](https://yupi.icu/img/image-20220419224055491.png)\n\n我在这里对该项目做一个简单的总结，希望让更多需要它的同学看到，把它变成自己的项目~\n\n\n\n## 项目简介\n\n这次做的是一个顺应潮流的项目， 基于 React + Spring Boot + MQ + AIGC 的 **智能数据分析平台** 。\n\n区别于传统 BI，用户只需要导入原始数据集、并输入分析诉求，就能自动生成可视化图表及分析结论，实现数据分析的降本增效。\n\n>  BI：即商业智能，可以简单理解为数据分析和可视化系统\n>\n>  AIGC：指用 AI 生成内容\n\n\n\n智能分析页面：\n\n![img](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/1687756780019-7fec8a50-a84a-4042-a2d4-bcf038a12c23-20230627180945775.png)\n\n\n\n我的图表页面：\n\n![img](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/1687756761369-0df53610-d478-44e2-9404-49446163b7d6-20230627180946030.png)\n\n\n\n支持异步分析：\n\n![img](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/1687756723426-f17cd6d3-302e-46d9-85e4-a54dbd768da3-20230627180946279.png)\n\n\n\n项目架构图：\n\n![img](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/1687756290740-41ba43c4-24b3-400f-a77a-db9321e0a200-20230627180946397.png)\n\n> 感兴趣的同学可以 **免费试看** 第一期项目回放：https://www.bilibili.com/video/BV1Cg4y1G7oy\n\n\n\n### 项目特点和收获\n\n该项目选题非常 **新颖** ，不同于泛滥的管理系统、博客、商城，本项目是结合当下最火的 **AIGC 技术** + 企业级 BI 业务场景的综合实战，紧跟时代潮流！\n\n项目中会带大家学习和实战：前后端高效开发方式、AIGC 应用开发、AI 提问技巧、系统优化、分布式限流、线程池、异步化、消息队列等一系列 **重点** 知识。\n\n鱼皮 **从 0 到 1 全程直播无剪辑** 地带大家开发完成项目，总课程时长近 **20 小时** ！从需求分析、技术选型、系统设计、项目初始化、前后端开发，每个环节我都 **从理论到实践** 给大家讲的明明白白、每个细节都不放过！\n\n除了学做项目之外，还能学会很多 **思考问题、对比方案** 的方法，提升排查问题、自主解决 Bug 的能力。\n\n还能获取到鱼皮的 **万用后端项目模板**，学习到最方便的全栈项目开发方式，熟练后 **几分钟开发一个新功能** 轻轻松松！\n\n\n\n### 本项目适合的同学\n\n本项目同时适合前端和后端，但是会更侧重后端。\n\n如果你是后端，已经学习过 Java Web 开发技术，希望做一个新颖的、有亮点的、写在简历上加分的项目，学习热门的 AIGC 应用开发、提升自己的编程和架构设计能力，那么非常欢迎来学习！\n\n如果你是前端，最好已经学习过 Vue 或 React 框架，可以通过本项目学习到快速开发前端项目的技巧，并且通过保姆级的入门实战学会一些后端技术。\n\n再介绍下这个项目用到的技术，都是主流的~\n\n\n\n### 技术选型（全栈项目）\n\n#### 前端\n\n- React 18\n- Ant Design Pro 5.x 脚手架\n- Umi 4 前端框架\n- Ant Design 组件库\n- Echarts 可视化库\n- OpenAPI 前端代码生成\n\n\n\n#### 后端\n\n- Java Spring Boot（万用后端模板）\n- MySQL 数据库\n- MyBatis-Plus 及 MyBatis X 自动生成\n- Redis + Redisson 限流\n- RabbitMQ 消息队列\n- 鱼聪明 AI SDK（AI 能力）\n- JDK 线程池及异步化\n- Easy Excel 表格数据处理\n- Swagger + Knife4j 接口文档生成\n- Hutool、Apache Common Utils 等工具库\n\n\n\n再列举下项目的大纲，这只是其中让我印象比较深刻的关键环节，直播过程中还讲了很多平时大家自己看视频根本学不到的做项目经验和编码技巧，比如：怎么又稳又快地自学一个新技术。\n\n\n\n## 项目大纲\n\n1. 项目介绍和计划\n   1. 需求分析\n   2. 技术选型\n   3. 业务流程和系统架构\n2. 前端项目初始化\n   1. Ant Design Pro 项目搭建\n   2. 初始化项目精简\n3. 后端项目初始化\n   1. Spring Boot 万用模板使用\n   2. 库表设计\n   3. 基础代码生成\n4. 前端基础开发联调\n   1. OpenAPI 代码生成\n   2. 前端模板代码优化\n   3. 登录功能开发\n5. **智能分析业务开发**\n   1. 业务流程梳理\n   2. AI 助手使用\n   3. 原始数据压缩\n   4. AIGC 入门实战\n   5. AIGC 提问技巧\n   6. 3 种 AI 调用方式\n   7. 后端接口开发\n6. 图表管理功能\n   1. 前端开发\n7. **系统分析及优化**\n   1. 文件安全性\n   2. 数据存储 - 分库分表\n   3. 限流 - 4 种限流算法\n   4. 限流 - Redisson 分布式限流实战\n8. **系统异步化改造**\n   1. 异步化业务流程\n   2. 线程池精讲（入门 + 原理 + 实战 + 面试）\n   3. 异步化改造 - 前端开发\n   4. 异步化改造 - 后端开发\n   5. 优化点扩展\n9. 系统现状分析\n10. 消息队列\n    1. 基础概念\n    2. 应用场景\n    3. 主流队列技术选型\n11. **RabbitMQ 入门实战**\n    1. AMQP 协议和基础概念\n    2. 5 种队列模型理论及实战\n    3. 核心特性 - 消息过期\n    4. 核心特性 - 消息确认\n    5. 核心特性 - 死信队列\n    6. 客户端介绍及 demo 开发\n12. BI 项目分布式队列改造\n\n\n\n## 项目资料\n\n我们整理好了项目完整源代码、详细的直播笔记和直播大纲，便于大家交流学习。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230627181952915.png)\n\n最关键的是，鱼皮已经整理好了这个项目的简历写法、亮点和扩展思路（30 个左右），做完项目后就能直接填满简历！\n\n\n\n---\n\n\n\n因为项目是在我的 [编程导航知识星球](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=145986907&lang=zh_CN#rd) 内直播做的，所以自然不能给大家免费发放啦。（要不然又成为一个泛滥的项目了）\n\n大家如果对这个项目感兴趣，欢迎加入编程导航，加入后可以跟着后续的直播做新项目、**随时观看** 超清完整的 **全部直播回放** 、完整的项目笔记以及踩坑指南、最新的项目源码等。\n\n最关键的是：做项目的过程中，有任何问题，都可以和大家一起交流或者 **直接向鱼皮本人提问** ！\n\n已经有不少小伙伴学起来了，还有很多大家自发整理的笔记。不得不说，做项目真的给了很多同学一个坚持学习的目标，大家的动力也更足了！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230627182431190.png)\n\n关于 [编程导航知识星球](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=145986907&lang=zh_CN#rd) ，我已经运营很久了，就不过多地介绍了，感兴趣的同学可以自行扫下方二维码加入体验，三天内不满意可全额退款~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/%E7%BB%93%E6%9D%9F.jpg)\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/al84XGPF-640.png",
        "language": null,
        "viewNum": 121,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-28T08:23:29.000+00:00",
        "updateTime": "2023-07-03T08:34:28.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1740,
          "coin": 170,
          "followeeNum": 862,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-03T15:46:55.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1673363574648475650",
        "title": "专科大三-Java-实习",
        "description": "鱼总好，想请你帮我看看简历还有什么可以优化的地方",
        "content": "马上就毕业了，然后也没有实习经历。最近才出来找工作，但是一言难尽。投的简历也蛮多的，面试机会却少的可怜。面试官问的问题有些是知道的，但是面试的时候却说不出来。想请教一下鱼总怎么样背八股文更有效率。\n\n![111.jpg](https://pic.code-nav.cn/post_picture/1615901355229052929/ITS9RXgU-111.jpg)\n\n![222.jpg](https://pic.code-nav.cn/post_picture/1615901355229052929/NXkqShTg-222.jpg)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 58,
        "thumbNum": 2,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1615901355229052929",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-26T16:12:20.000+00:00",
        "updateTime": "2023-07-03T09:53:10.000+00:00",
        "user": {
          "id": "1615901355229052929",
          "planetCode": "24021",
          "userName": "鱼刺",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1615901355229052929/NnY8jEo1-头像.jpg",
          "gender": 1,
          "userProfile": "练习时长一年半的Java练习生",
          "userRole": "vip",
          "interests": [],
          "place": "广州",
          "birthday": "2001-10-08",
          "school": null,
          "major": null,
          "education": "专科",
          "graduationYear": 2023,
          "jobStatus": "求职中",
          "company": null,
          "job": "后端",
          "workYear": 0,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-06-19T14:42:21.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-19T02:37:59.000+00:00",
          "updateTime": "2023-06-26T15:29:36.000+00:00"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1672134026791542786",
        "title": "React 的常见初学者错误",
        "description": "react 开发中常见错误记录总结",
        "content": "## React 的常见初学者错误\n\n​\t这是我关注的一位前端开发者的分享，分享的非常棒！值得被更多人看到，原文英文版本，我做了翻译，希望对 React 开发者有所帮助。\n\n​\t在我最近开发的时候，在遇到复杂状态管理和副作用的时候，就会经常不能完全想到所有可能发生的情况，导致一些莫名其妙的 bug，如果你也是，那看完吧，一定有新的收获。以下是正文部分：\n\n“几年前，我在当地的一个编码训练营教 React，我注意到有一些事情让学生措手不及。人们不断掉进同一个坑里！在本教程中，我们将探索 8 个最常见的陷阱。您将学习如何绕过它们，并希望能够避免很多挫败感。为了保持这篇博客文章轻松流畅，我们不会过多探讨这些陷阱背后的原因。这更像是一个快速参考。下面看下常见的问题吧！\n\n> ##### 目标受众\n>\n> 这篇文章是为那些对React基础知识已经有所了解，但在他们的学习旅程中仍然处于初级阶段的开发者编写的。\n\n### 1. 使用 0 作为判断依据\n\n​\t好的，我们从其中一个最普遍的陷阱开始。我在一些生产应用程序中实际遇到过这个问题！\n\n​\t请看下以下代码：\n\n```js\n// react app.js\nimport React from 'react';\nimport ShoppingList from './ShoppingList';\n\nfunction App() {\n  const [items, setItems] = React.useState([]);\n  \n  return (\n    <div>\n      {items.length && <ShoppingList items={items} />}\n    </div>\n  );\n}\n\nexport default App;\n```\n\n```js\n// ShoppingList.js\nimport React from 'react';\n\nfunction ShoppingList({ items }) {\n  return (\n    <>\n      <h1>Shopping List</h1>\n      <ul>\n        {items.map((item, index) => {\n          // NOTE: We shouldn't use “index” as the key!\n          // This is covered later in this post \uD83D\uDE04\n          return (\n            <li key={index}>\n              {item}\n            </li>\n          );\n        })}\n      </ul>\n    </>\n  );\n}\n\nexport default ShoppingList\n```\n\n​\t我们的目标是有条件地显示一个购物清单。如果数组中至少有1个项目，我们应该渲染一个ShoppingList元素。否则，我们不应该渲染任何内容。**然而，我们最终在 UI 中得到一个随机的 `0` ！**\n\n​\t发生这种情况是因为 `items.length` 的计算结果为 `0` 。由于 0 在 JavaScript 中是一个虚假值，因此 `&&` 运算符短路，整个表达式解析为 `0` 。实际上，就好像我们这样做了一样：\n\n```jsx\nfunction App() {\n  return (\n    <div>\n      {0}\n    </div>\n  );\n}\n```\n\n​\t与其他假值（如''、null、false等）不同，数字0是JSX中的一个有效值。毕竟，在许多情况下，我们确实希望打印数字0！\n\n**如何修复：** 我们的表达式应该使用一个“纯粹”的布尔值（true/false）：\n\n```jsx\nfunction App() {\n  const [items, setItems] = React.useState([]);\nreturn (\n    <div>\n      {items.length > 0 && (\n        <ShoppingList items={items} />\n      )}\n    </div>\n  );\n}\n```\n\n`items.length > 0` 将始终计算为 `true` 或 `false` ，因此我们永远不会有任何问题。或者，我们可以使用三元表达式：\n\n```jsx\nfunction App() {\n  const [items, setItems] = React.useState([]);\nreturn (\n    <div>\n      {items.length\n        ? <ShoppingList items={items} />\n        : null}\n    </div>\n  );\n}\n```\n\n​\t这两种选择都是完全有效的，这取决于**个人品味**。\n\n### 2. 不正确使用状态\n\n​\t让我们继续使用我们的购物清单示例。假设我们能够添加新项目：\n\n```js\n// app.js\nimport React from 'react';\nimport ShoppingList from './ShoppingList';\nimport NewItemForm from './NewItemForm';\n\nfunction App() {\n  const [items, setItems] = React.useState([\n    'apple',\n    'banana',\n  ]);\n  \n  function handleAddItem(value) {\n    items.push(value);\n    setItems(items);\n  }\n  \n  return (\n    <div>\n      {items.length > 0 && <ShoppingList items={items} />}\n      <NewItemForm handleAddItem={handleAddItem} />\n    </div>\n  )\n}\n\nexport default App;\n```\n\n```js\n// ShoppingList.js\nimport React from 'react';\n\nfunction ShoppingList({ items }) {\n  return (\n    <>\n      <h1>Shopping List</h1>\n      <ul>\n        {items.map((item, index) => {\n          // NOTE: We shouldn't use “index” as the key!\n          // This is covered later in this post \uD83D\uDE04\n          return (\n            <li key={index}>\n              {item}\n            </li>\n          );\n        })}\n      </ul>\n    </>\n  );\n}\n\nexport default ShoppingList;\n```\n\n```js\n// NewItemFrom.js\nimport React from 'react';\n\nfunction NewItemForm({ handleAddItem }) {\n  const [value, setValue] = React.useState('');\n  \n  return (\n    <form\n      onSubmit={(event) => {\n        event.preventDefault();\n        \n        handleAddItem(value);\n        setValue('');\n      }}\n    >\n      {/* We'll touch on this ID stuff later too! */}\n      <label htmlFor=\"new-item-input\">\n        Item:\n      </label>\n      <input\n        value={value}\n        onChange={event => setValue(event.target.value)}\n      />\n      <button>\n        Add Item\n      </button>\n    </form>\n  );\n}\n\nexport default NewItemForm;\n```\n\n可看到如下：\n\n![image-20230623130414761](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623130414761.png)\n\n​\t每当用户提交一个新项目时，`handleAddItem`函数会被调用。不幸的是，它目前无法正常工作！当我们输入一个项目并提交表单时，该项目并没有被添加到购物清单中。\n\n**问题**出在我们违反了React中可能是最重要的规则之一：我们修改了**状态**的值。具体来说，问题是这一行：\n\n```jsx\n// app.js\nfunction handleAddItem(value) {\n  items.push(value);\n  setItems(items);\n}\n```\n\n​\tReact 依靠**状态变量的身份**（也就是这里的 useState hooks）来判断状态何时发生了变化。当我们把一个项目推到数组中时，我们不会改变该数组的身份，所以 React 无法判断这个值已经改变。\n\n**如何修复：** 我们需要创建一个全新的数组。以下是我的做法：\n\n```jsx\n// app.js\nfunction handleAddItem(value) {\n  const nextItems = [...items, value]; // 不知道有人看过我之前的文章不，这里也是遵守 react 的不可变性原则\n  setItems(nextItems);\n}\n```\n\n​\t与其修改现有的数组，我选择从头开始创建一个新的数组。这个新数组包含了与原数组完全相同的所有项（借助展开语法...），以及新添加的项。这里的区别在于**修改现有项**与**创建新项**之间的差异。当我们将一个值传递给像 setCount 这样的**状态设置函数**时，它需要是一个**新的实体**。**对象也是如此：**\n\n```js\n// ❌ Mutates an existing object\nfunction handleChangeEmail(nextEmail) {\n  user.email = nextEmail;\n  setUser(user);\n}\n// ✅ Creates a new object\nfunction handleChangeEmail(email) {\n  const nextUser = { ...user, email: nextEmail };\n  setUser(nextUser);\n}\n```\n\n​\t基本上，... 语法是一种将数组/对象中的所有内容复制/粘贴到全新实体中的方式。这确保一切正常运作。\n\n### 3. 不生成密钥\n\n以下是您之前可能看到的警告：\n\n> Warning: Each child in a list should have a unique \"key\" prop.\n>\n> 警告：列表中的每个子元素应该有一个唯一的 \"key\" 属性。\n\n最常见的情况是在对数据进行映射时发生此错误。以下是一个违反此规则的示例：\n\n```js\n// app.js\nimport React from 'react';\nimport ShoppingList from './ShoppingList';\nimport NewItemForm from './NewItemForm';\n\nfunction App() {\n  const [items, setItems] = React.useState([\n    'apple',\n    'banana',\n    'carrot',\n  ]);\n  \n  function handleAddItem(value) {\n    const nextItems = [...items, value]\n    setItems(nextItems);\n  }\n  \n  return (\n    <div>\n      {items.length > 0 && <ShoppingList items={items} />}\n      <NewItemForm handleAddItem={handleAddItem} />\n    </div>\n  )\n}\n\nexport default App;\n```\n\n```js\n// ShoppingList.js\nimport React from 'react';\n\nfunction ShoppingList({ items }) {\n  return (\n    <ul>\n      {items.map((item) => {\n        return (\n          <li>{item}</li>\n        );\n      })}\n    </ul>\n  );\n}\n\nexport default ShoppingList;\n```\n\n```js\n// NewItemForm.js\nimport React from 'react';\nfunction NewItemForm({ handleAddItem }) {\n  const [value, setValue] = React.useState('');\n  \n  return (\n    <form\n      onSubmit={(event) => {\n        event.preventDefault();\n        \n        handleAddItem(value);\n        setValue('');\n      }}\n    >\n      {/* We'll touch on this ID stuff later too! */}\n      <label htmlFor=\"new-item-input\">\n        Item:\n      </label>\n      <input\n        value={value}\n        onChange={event => setValue(event.target.value)}\n      />\n      <button>\n        Add Item\n      </button>\n    </form>\n  );\n}\n\nexport default NewItemForm;\n```\n\n你会看到：\n\n![image-20230623132957917](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623132957917.png)\n\n​\t每当我们渲染一个元素数组时，我们需要为 React 提供额外的上下文信息，以便它能够识别每个项。关键是，这个标识符需要是唯一的。许多在线资源会建议使用数组索引来解决这个问题：\n\n```js\n// ShoppingList.js\nfunction ShoppingList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => {\n        return (\n          <li key={index}>{item}</li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\n​\t我不认为这是一个好的建议。这种方法有时可以工作，但在其他情况下可能会引发一些严重的问题。随着对 React 工作原理的更深入理解，您将能够在每个具体情况下判断是否可以使用这种方法，但老实说，我认为以一种始终安全的方式解决问题会更容易。这样，您就不必担心它！\n\n**下面是计划：** 每当向列表中添加新项时，我们将为其生成一个唯一的ID：\n\n```js\n// app.js\nfunction handleAddItem(value) {\n  const nextItem = {\n    id: crypto.randomUUID(),\n    label: value,\n  };\n  const nextItems = [...items, nextItem];\n  setItems(nextItems);\n}\n```\n\n`crypto.randomUUID `是内置于浏览器中的方法（它不是第三方包）。它在所有主要浏览器中都可用。它与加密货币无关。该方法生成一个类似于 `d9bb3c4c-0459-48b9-a94c-7ca3963f7bd0` 的唯一字符串。通过在用户提交表单时动态生成一个 ID，我们确保购物清单中的每个项都具有唯一的 ID。以下是如何将其应用为键的方法：\n\n```js\n// ShoppingList.js\nfunction ShoppingList({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => {\n        return (\n          <li key={item.id}>\n            {item.label}\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n```\n\n重要的是，我们希望在状态更新时生成ID，而不是这样做：\n\n```jsx\n// ❌ This is a bad idea\n<li key={crypto.randomUUID()}>\n  {item.label}\n</li>\n```\n\n在 JSX 中这样生成会导致键在**每次渲染时发生变化**。当键发生变化时，React将销毁并重新创建这些元素，这可能对**性能产生重大负面影响**。这种模式——在创建数据时生成键——可以应用于各种情况。例如，下面是我在从服务器获取数据时创建唯一ID的方式：\n\n```js\nconst [data, setData] = React.useState(null);\nasync function retrieveData() {\n  const res = await fetch('/api/data');\n  const json = await res.json();\n  // The moment we have the data, we generate\n  // an ID for each item:\n  const dataWithId = json.data.map(item => {\n    return {\n      ...item,\n      id: crypto.randomUUID(),\n    };\n  });\n  // Then we update the state with\n  // this augmented data:\n  setData(dataWithId);\n}\n```\n\n### 4. 缺少空格\n\n这是我在网络上经常看到的一个非常让人困惑的问题。\n\n```js\nimport React from 'react';\n\nfunction App() {\n  return (\n    <p>\n      Welcome to Corpitech.com!\n      <a href=\"/login\">Log in to continue</a>\n    </p>\n  );\n}\n\nexport default App;\n```\n\n你会看到：![image-20230623133756836](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623133756836.png)\n\n注意到这两个句子被混在一起了：\n\n![image-20230623133859746](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623133859746.png)\n\n这是因为 **JSX 编译器**（将我们编写的 JSX 转换为适用于浏览器的 JavaScript 的工具）**无法真正区分语法上的空格和我们为缩进/代码可读性而添加的空格**。\n\n**如何修复它：** 我们需要在文本和锚点标记之间添加一个**显式的空格字符**：\n\n```jsx\n<p>\n  Welcome to Corpitech.com!\n  {' '}\n  <a href=\"/login\">Log in to continue</a>\n</p>\n```\n\n一个小小的专业技巧：如果您使用 `Prettier`，它会自动为您添加这些空格字符！只需确保让它进行格式化（不要提前将内容拆分为多行）。\n\n> 为什么 React 团队没有解决这个问题？\n>\n> 当我第一次了解到这种策略时，我也觉得有些凌乱。为什么 React 团队不能修复它，使其按照我们的预期工作呢？！我后来意识到这个问题并没有完美的解决方案。如果 React 开始将缩进解释为语法上的空格，可以解决这个问题，但也会引入一系列其他问题。最终，尽管它看起来有些笨拙，但我认为这是正确的决定。这是最不糟糕的选择！\n\n### 5. 在修改状态后访问它\n\n​\t这个问题在某个时刻都会让人措手不及。在我在一家本地编程训练营教授时，我已经记不清有多少次有人因为这个问题向我求助了。下面是一个最简单的计数器应用程序：点击按钮会增加计数。看看你能否发现问题所在：\n\n```js\nimport React from 'react';\n\nfunction App() {\n  const [count, setCount] = React.useState(0);\n  \n  function handleClick() {\n    setCount(count + 1);\n    \n    console.log({ count });\n  }\n  \n  return (\n    <button onClick={handleClick}>\n      {count}\n    </button>\n  );\n}\n\nexport default App;\n```\n\n你会看到：\n\n![image-20230623134419724](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623134419724.png)\n\n在增加计数状态变量后，我们将其值记录到控制台。令人奇怪的是，它记录了错误的值：\n\n![image-20230623134525645](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623134525645.png)\n\n问题出在这里：React 中的状态设置函数（例如 setCount）是异步的。\n这是有问题的代码是这里：\n\n```js\nfunction handleClick() {\n  setCount(count + 1);\n  console.log({ count });\n}\n```\n\n很容易错误地认为 setCount 函数类似于赋值，好像这样做是等同于这样的操作：\n\n```js\ncount = count + 1;\nconsole.log({ count });\n```\n\n​\t然而，React 并不是这样构建的。当我们调用 setCount 时，我们并没有重新赋值给一个变量，而是安排了一个更新操作。\n\n​\t对于我们完全理解这个概念可能需要一些时间，但下面的解释或许有助于更好地理解：我们无法重新赋值给 count 变量，因为它是一个常量！\n\n```js\n// Uses `const`, not `let`, and so it can't be reassigned\nconst [count, setCount] = React.useState(0);\ncount = count + 1; // Uncaught TypeError:\n                   // Assignment to constant variable\n```\n\n那么我们应该如何修复这个问题呢？幸运的是，我们已经知道这个值应该是什么。我们需要将它存储在一个变量中，以便我们可以访问它：\n\n```js\nfunction handleClick() { // 再次验证不可变性重要性，使用新的变量记录最新的状态\n  const nextCount = count + 1;\n  setCount(nextCount);\n  // Use `nextCount` whenever we want\n  // to reference the new value:\n  console.log({ nextCount });\n}\n```\n\n​\t我喜欢在这种情况下使用“next”前缀（比如nextCount、nextItems、nextEmail等）。这样对我来说更清晰，我们不是更新当前值，而是安排下一个值。\n\n### 6. 返回多个元素\n\n​\t有时，一个组件需要返回多个顶级元素。例如：\n\n```js\n// app.js\nimport React from 'react';\nimport LabeledInput from './LabeledInput';\n\nfunction App() {\n  const [name, setName] = React.useState('');\n  \n  return (\n    <LabeledInput\n      id=\"name\"\n      label=\"Your name\"\n      value={name}\n      onChange={(event) => setName(event.target.value)}\n    />\n  );\n}\n\nexport default App;\n```\n\n```js\n// LabeledInput.js\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <label htmlFor={id}>\n      {label}\n    </label>\n    <input\n      id={id}\n      {...delegated}\n    />\n  );\n}\n\nexport default LabeledInput;\n```\n\n你会看到：\n\n![image-20230623135153465](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623135153465.png)\n\n我们希望我们的 LabeledInput 组件返回两个元素：一个 `<label>` 和一个 `<input>`。令人沮丧的是，我们遇到了一个错误：\n\n![image-20230623135238318](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623135238318.png)\n\n这是因为 JSX 编译为普通的 JavaScript。下面是在浏览器中运行时这段代码的样子：\n\n```js\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    React.createElement('label', { htmlFor: id }, label)\n    React.createElement('input', { id: id, ...delegated })\n  );\n}\n```\n\n在 JavaScript 中，我们不能像这样返回多个值。这也是为什么这种写法不起作用的原因：\n\n```js\nfunction addTwoNumbers(a, b) {\n  return (\n    \"the answer is\"\n    a + b\n  );\n}\n```\n\n我们该如何修复呢？很长一段时间以来，标准做法是将这两个元素包装在一个包裹标签中，比如 `<div>`：\n\n```jsx\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <div>\n      <label htmlFor={id}>\n        {label}\n      </label>\n      <input\n        id={id}\n        {...delegated}\n      />\n    </div>\n  );\n}\n```\n\n通过将 `<label>` 和 `<input>` 包装在 `<div>` 中，我们只返回一个顶层元素！以下是它在普通的 JavaScript 中的样子：\n\n```js\nfunction LabeledInput({ id, label, ...delegated }) {\n  return React.createElement(\n    'div',\n    {},\n    React.createElement('label', { htmlFor: id }, label),\n    React.createElement('input', { id: id, ...delegated })\n  );\n}\n```\n\n​\tJSX 是一个很棒的抽象，但它常常会掩盖关于 JavaScript 的基本真理。我认为，查看 JSX 如何转换为普通的 JavaScript，以了解实际发生的情况往往是有帮助的。通过这种新的方法，我们返回一个单独的元素，而该元素包含两个子元素。问题解决了！但我们可以使用片段（fragments）进一步改进这个解决方案：\n\n```jsx\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <React.Fragment>\n      <label htmlFor={id}>\n        {label}\n      </label>\n      <input\n        id={id}\n        {...delegated}\n      />\n    </React.Fragment>\n  );\n}\n```\n\n​\t`React.Fragment`是一个专门用来解决这个问题的React组件。它允许我们将多个顶级元素捆绑在一起，而不会影响DOM。这非常棒：这意味着我们不会在标记中加入不必要的`<div>`。它还有一个便捷的简写方式，我们可以像这样编写片段：\n\n```jsx\nfunction LabeledInput({ id, label, ...delegated }) {\n  return (\n    <>\n      <label htmlFor={id}>\n        {label}\n      </label>\n      <input\n        id={id}\n        {...delegated}\n      />\n    </>\n  );\n}\n```\n\n我喜欢这里的符号意义：React团队选择使用一个空的HTML标签`<>`来表示片段不会产生任何实际的标记。\n\n### 7. 从不受控制变为受控制状态\n\n让我们来看一个典型的表单示例，将一个输入与React状态绑定起来：\n\n```js\nimport React from 'react';\n\nfunction App() {\n  const [email, setEmail] = React.useState();\n  \n  return (\n    <form>\n      <label htmlFor=\"email-input\">\n        Email address\n      </label>\n      <input\n        id=\"email-input\"\n        type=\"email\"\n        value={email}\n        onChange={event => setEmail(event.target.value)}\n      />\n    </form>\n  );\n}\n\nexport default App;\n```\n\n你会看到：\n\n![image-20230623140328986](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623140328986.png)\n\n如果你在这个输入框中开始输入，你会注意到控制台上会出现一个警告：\n\n![image-20230623140357471](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623140357471.png)\n\n解决方法如下：我们需要将 `email` 状态初始化为空字符串：\n\n```js\nconst [email, setEmail] = React.useState('');\n```\n\n​\t当我们设置value属性时，我们告诉 React 我们希望这是一个受控输入框。但是，这只有在我们传递一个定义的值时才起作用！通过将email初始化为空字符串，**我们确保 value 永远不会被设置为undefined**。\n\n> 受控输入\n>\n> 如果您想详细了解为什么这是必要的，以及什么是“受控输入”，我们将在我最近发布的教程中深入探讨这些想法：[React中的数据绑定](https://www.joshwcomeau.com/react/data-binding/)\n\n​\tJSX 被设计得看起来很像 HTML，但它们之间有一些令人惊讶的差异，往往会让人措手不及。大多数差异都有很好的文档记录，而且控制台的警告通常非常具体和有帮助。例如，如果你意外使用 class 而不是className，React会准确告诉你问题所在。但有一个微妙的差异经常让人困惑：style属性。在HTML中，style是以字符串的形式表示的：\n\n```html\n<button style=\"color: red; font-size: 1.25rem\">\n  Hello World\n</button>\n```\n\n但是，在 JSX 中，我们需要将其指定为一个对象，并带有驼峰属性名称。在下面的代码中，我试图做到这一点，但出现了错误。你能找出错误吗？\n\n```js\nimport React from 'react';\n\nfunction App() {\n  return (\n    <button\n      style={ color: 'red', fontSize: '1.25rem' }\n    >\n      Hello World\n    </button>\n  );\n}\n\nexport default App;\n```\n\n你会看到：\n\n![image-20230623140901535](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623140901535.png)\n\n问题是我需要使用**双波浪线**，如下所示：\n\n```js\n<button\n  // \"{{\", instead of \"{\":\n  style={{ color: 'red', fontSize: '1.25rem' }}\n>\n  Hello World\n</button>\n```\n\n为了理解为什么这样是必要的，我们需要稍微了解一下这个语法。在JSX中，我们使用花括号来创建一个表达式插槽。我们可以在这个插槽中放置任何有效的JavaScript表达式。例如：\n\n```jsx\n<button className={isPrimary ? 'btn primary' : 'btn'}>\n```\n\n无论我们在{}中放置什么，都将被视为JavaScript进行求值，并将结果设置为该属性的值。className将是'btn primary'或'btn'。对于style，我们首先需要创建一个表达式插槽，然后将一个JavaScript对象传递到这个插槽中。我认为如果我们将对象提取到一个变量中，会更清晰明了：\n\n```js\n// 1. Create the style object:\nconst btnStyles = { color: 'red', fontSize: '1.25rem' };\n// 2. Pass that object to the `style` attribute:\n<button style={btnStyles}>\n  Hello World\n</button>\n// Or, we can do it all in 1 step:\n<button style={{ color: 'red', fontSize: '1.25rem' }}>\n```\n\n外层的花括号创建了JSX中的\"表达式插槽\"。内层的花括号创建了一个JavaScript对象，用于保存我们的样式。\n\n### 8. 异步的 effect 函数\n\n​\t假设我们有一个函数，在挂载时从 API 中获取一些用户数据。我们将使用 useEffect 钩子，并希望使用 await 关键字。以下是我第一次尝试的代码：\n\n```js\n// app.js\nimport React from 'react';\nimport UserProfile from './UserProfile';\n\nfunction App() {\n  return (\n    <UserProfile userId=\"abc123\" />\n  );\n}\n\nexport default App;\n```\n\n```js\n// UserProfile.js\nimport React from 'react';\nimport { API } from './constants';\n\nfunction UserProfile({ userId }) {\n  const [user, setUser] = React.useState(null);\n  \n  React.useEffect(() => {\n    const url = `${API}/get-profile?id=${userId}`;\n    const res = await fetch(url);\n    const json = await res.json();\n    \n    setUser(json.user);\n  }, [userId]);\n  \n  if (!user) {\n    return 'Loading…';\n  }\n  \n  return (\n    <section>\n      <dl>\n        <dt>Name</dt>\n        <dd>{user.name}</dd>\n        <dt>Email</dt>\n        <dd>{user.email}</dd>\n      </dl>\n    </section>\n  );\n}\n\nexport default UserProfile;\n```\n\n```js\n// constants.js\nexport const API = 'https://jor-test-api.vercel.app/api';\n```\n\n你会看到：\n\n![image-20230623141348771](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623141348771.png)\n\n不幸的是，我们收到一个错误：\n\n![image-20230623141402587](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230623141402587.png)\n\n**这是修正的方法：**我们需要在 effect 中创建一个单独的异步函数：\n\n```js\nReact.useEffect(() => {\n  // Create an async function...\n  async function runEffect() {\n    const url = `${API}/get-profile?id=${userId}`;\n    const res = await fetch(url);\n    const json = await res.json();\n    setUser(json);\n  }\n  // ...and then invoke it:\n  runEffect();\n}, [userId]);\n```\n\n为了理解为什么需要这个变通方法，值得考虑一下 async 关键字的实际作用。例如，你会猜测下面这个函数返回什么？\n\n```js\nasync function greeting() {\n  return \"Hello world!\";\n}\n```\n\n乍一看，似乎很明显：它返回字符串` \"Hello world!\"`！但实际上，这个函数返回一个 Promise。这个 Promise 解析为字符串 `\"Hello world!\"`。这是一个问题，因为 useEffect 钩子并不期望我们返回一个 Promise！它期望我们返回无值（就像我们上面的示例中所做的），或者返回一个清除函数。清除函数远超出了本教程的范围，但它们非常重要。大多数的 effect 都会有一些拆除逻辑，我们需要尽快将其提供给 React，这样 React 就可以在**依赖项更改或组件卸载时**调用它。 通过使用\"单独的异步函数\"策略，我们仍然可以立即返回一个清除函数：\n\n```js\nReact.useEffect(() => {\n  async function runEffect() {\n    // Effect logic here\n  }\n  runEffect();\n  return () => {\n    // Cleanup logic here\n  }\n}, [userId]);\n```\n\n你可以将这个函数命名为任何你喜欢的名称，但我喜欢使用通用名称 runEffect。它清晰地表明它包含了主要的 effect 逻辑。\n\n### 9. 培养直觉 （经验）\n\n​\t一开始，我们在这个教程中看到的很多修复方法似乎相当随意。为什么我们需要提供一个唯一的键（key）？为什么我们无法在改变状态后访问它？为什么useEffect如此棘手？React一直以来都相当棘手，尤其是现在使用hooks时更是如此。需要一段时间才能理解一切。我在2015年开始使用React，还记得当时想：“这玩意太酷了，但我完全不知道它是如何工作的。” \uD83D\uDE05从那时起，我逐渐构建了自己关于React的思维模型，一块一块地拼凑。我经历了一系列的顿悟，每一次顿悟都使我的思维模型更加坚实、更加完善。我开始理解React为什么会以这种方式工作。我发现自己不必记住任意的规则；相反，我可以依靠自己的直觉。很难言喻 React 对我来说变得更加有趣了！在过去的一年里，我一直在开发一门名为《React的乐趣》的交互式自学在线课程。这是一门面向初学者的课程，旨在帮助你建立对React工作原理的直觉，以便用它构建丰富、动态的Web应用程序。我的课程与其他课程不同；你不会坐在那里看我连续几个小时地编码。《React的乐趣》结合了许多不同的媒体形式：视频、交互式文章、挑战性练习、以真实世界为灵感的项目，甚至还有一两个小游戏。《React的乐趣》将在几个月内发布。你可以在课程主页上了解更多信息，并注册接收更新：[《react的乐趣》](https://www.joyofreact.com/)\n\n”\tEND\n\n​\t我想补充两个我最近开发遇到的问题，\n\n1. 第一个就是 useState 的异步问题，当我们setState后如果立刻取值 state 得到的可能不是最新的值，这真的很坑人，\n2. 第二个是 在React 中，如果想要立刻获取到最新的值，你可以使用 useRef 进行同步，但是它不能更新UI视图，所以一定要记得使用 state 去触发页面 UI 更新，\n3. 当面临列表数据，并且页面渲染复杂时候，一定要记得给组件使用 React.memo 包裹，当props更新的时候才重新渲染页面，这样就能避免不必要的刷新\n\n​\t文章很长，需要花10~15分钟才能看完，认真看完的同学，你真的好厉害，也希望你在 React 的开发者寻找到自己的最佳实践\n\n\n\n原文链接： [常见的React初学者错误](https://www.joshwcomeau.com/react/common-beginner-mistakes/)\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/qLeUiada-Snipaste_2023-06-23_14-45-25.png",
        "language": null,
        "viewNum": 36,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-23T06:46:33.000+00:00",
        "updateTime": "2023-07-02T14:29:01.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 11,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-07-02T15:18:14.000+00:00"
        },
        "tags": [
          "文章",
          "React",
          "笔记",
          "经验分享"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1671706615327285249",
        "title": "专科大三-Go-实习/秋招",
        "description": null,
        "content": "鱼皮哥您好，我想向您咨询一些简历相关的问题\n### 个人情况\n本人专科大三准备毕业开始要找工作了，这段时间也一直在用 Go 重写你的项目，现在写的差不多了，简历也写出来第一版了，鱼皮哥可以帮我看一下简历有哪些地方不足要修改的地方吗，对于两个项目都还没有上线，域名还在备案，估计这几天就下来了，到时候可以部署上线\n### 提问\n我想问一下面试的时候这个项目是说用go重写的还是自己写的，我怕说自己写的，前端那方面有些地方答不上来\n### 简历\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1609234177662648321/YkQU9IJm-a01c29dea3aed9d005f2c034b0403fa.png",
        "language": null,
        "viewNum": 38,
        "thumbNum": 0,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1609234177662648321",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-22T02:28:10.000+00:00",
        "updateTime": "2023-07-03T09:54:08.000+00:00",
        "user": {
          "id": "1609234177662648321",
          "planetCode": "3665",
          "userName": "helloworg",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1609234177662648321/q7qoH4jk-331622120_235617872144916_5453336620106197415_n.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T22:35:31.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-31T17:05:00.000+00:00",
          "updateTime": "2023-06-22T02:16:41.000+00:00"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1671131561837211650",
        "title": "上线啦！",
        "description": null,
        "content": "大家好，我是鱼皮。今天给大家介绍下我们公司的新朋友 —— 鱼聪明！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609175912455.png)\n\n是不是看上去就像个大聪明哈哈，这其实是我们公司的吉祥物。当然啦，她以后会经常出现在我们的产品家族和周边中~\n\n比如我们最新上线的 AI 助手网站 —— 鱼聪明 AI：\n\n> 地址非常好记：https://yucongming.com\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609180131212.png)\n\n给大家介绍下这个网站。这是我们自主研发的 AI 助手平台，主打一个 **简单易用** ，让所有人都能 **无门槛** 地和 AI 交流，使用 AI 来提高学习 / 工作效率，感受到 AI 的强大！\n\n你可以用鱼聪明来做什么呢？\n\n目前总共有 **7 大功能** ！一定要看到最后，有很强大的功能哦~\n\n\n\n### 一、对话 AI 助手\n\n进入主页，能看到非常多现成的、实用的 AI 助手，支持从几百个 AI 助手中搜索，总有一个你想要的：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609180602884.png)\n\n点击 `开始聊天` ，就能立即和我们的鱼聪明聊天啦，你可以让她帮助你解决学习、工作上的问题，提高效率：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609180741122.png)\n\n你可以和【小红书种草文案】大师交流，5 秒钟，就帮你写出一篇小红书风格的文案 \uD83E\uDDD1\uD83C\uDFFB‍\uD83E\uDDB2\uD83D\uDCDA！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609181136636.png)\n\n你可以和【软件开发大佬】交流，让他帮你学编程、改 Bug，转移头秃 \uD83D\uDC36！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609181337139.png)\n\n你可以和【歌曲推荐者】交流，他会根据你的喜好给你推荐更多歌曲~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609181014243.png)\n\n你甚至还能和鸡哥交流，鸡哥的 RAP 非常不错，很适合新手入门说唱：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609181518198.png)\n\n\n\n### 二、创建个人助手\n\n除了使用现成的助手外，你也可以轻松创建属于自己的 AI 助手，打造属于自己的超级辅助！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609181840376.png)\n\n比如某位用户创建的【冒险游戏】助手，就很不错，可以轻松生成 “一盘大局”，想象力可能比人类还要丰富哦~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609181748222.png)\n\n如果你不太熟悉 AI，填个名称、头像就能创建 AI 助手了；但如果你想做一个精品的超级助手，我们还支持非常多的配置，让你自由定制~\n\n比如添加对话示例（引导用户使用）、还可以把助手公开让别人一起使用：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609182134881.png)\n\n还有更多的高级配置，比如示例问答、AI 的想象力等等，能够让你的 AI 更听话、更强大！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609182222145.png)\n\n你还可以把自己用心制作的 AI 助手分享给别人，我们设计了精美的分享海报，独乐乐不如众乐乐，帮助更多人使用 AI，多是一件美事啊~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609182344384.png)\n\n\n\n### 三、对话小插件\n\n除了向 AI 发消息、它会回复你文字之外，我们还提供了一些实用的小插件。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609182809066.png)\n\n比如分享消息，可以把有意思的对话记录 **生成为海报** 分享给别人，传递快乐：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609182820737.png)\n\n还可以语音朗读消息，这个功能可以用来 “学单词”、“学语言”，毕竟谁不想听一听小鸡说英文、唱 RAP 呢？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609182954857.png)\n\n还可以一键下载对话为文档，如果你要用 AI 生成论文或高考作文，这个功能会非常实用~\n\n\n\n### 四、对话共享\n\n如果你觉得自己和 AI 的对话非常有趣、实用，除了上面的分享消息外，我们还支持公开 / 私密两种 **对话共享** 能力。\n\n类似一个群聊，比如可以邀请你的好朋友拉到鸡哥会话中，快乐加倍！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609183643075.png)\n\n\n\n### 五、开放平台\n\n除了可以在网页上使用鱼聪明外，鱼皮本身作为程序员，当然也考虑到了程序员朋友们的需求啦。\n\n所以我们提供了开放平台，让你在程序中使用 AI 助手！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609183955472.png)\n\n只需要使用我们开源的 SDK（工具代码），就能轻轻松松，只用几行代码使用 AI 助手能力！\n\n示例代码如下，可以选择要使用的助手：\n\n```java\n// 构造请求\nDevChatRequest devChatRequest = new DevChatRequest();\ndevChatRequest.setModelId(1651468516836098050L);\ndevChatRequest.setMessage(\"鱼皮\");\n\n// 获取 AI 助手的回复\nBaseResponse<DevChatResponse> response = client.doChat(devChatRequest);\nSystem.out.println(response.getData());\n```\n\n由于我们目前人力有限，所以只能先提供 Java SDK，大家如果感兴趣的话，欢迎贡献其他语言的 SDK 哦~\n\n\n\n### 六、AI 应用\n\n这是鱼聪明 AI 的重磅功能！除了对话之外，我们还提供了功能更强大的 AI 应用。\n\n目前第一批上线的两个应用是：AI 写书和 AI 绘画\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609184634330.png)\n\n\n\n#### AI 写书\n\n只需要输入你想写的书的名称、书的内容介绍，就可以让 AI 自动帮你生成一本书！\n\n比如下面这个，还可以指定书的风格：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609184933623.png)\n\n点击【生成书籍】后，还能够实时浏览书籍的生成进度。建议大家快去试一试，这个应用已经成为我每日的快乐源泉了：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609185106483.png)\n\n生成结束后，当然还可以下载书籍文档：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609185225990.png)\n\n\n\n#### AI 绘画\n\n只需要输入你想画画的内容，比如 “鸡打篮球”，就能轻松生成 4 张富有创造力的图片：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609185339473.png)\n\n由于我们接入的是国外最主流的 AI 绘画平台，对中文的支持度不是很友好，所以我们还提供了 **一键优化描述** 的功能：\n\n> 当然，优化描述也是让 AI 做的，不是直接翻译哈哈\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609185620012.png)\n\n点击生成图片后，就可以实时浏览绘画生成的进度：\n\n> 就像在孵小鸡一样，能看到最开始的样子，还是很有趣的~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609190632379.png)\n\n很快图片就生成啦，来看看效果吧~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609190724211.png)\n\n这两个 AI 应用只会开始，大家喜欢的话，后面我们会推出更多有趣又实用的 AI 应用~\n\n\n\n### 七、AI 导航\n\n如果你需要更多我们没有的 AI 功能，可以让鱼聪明帮你快速搜索，绝大多数的 AI 工具站都有收录~\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230609183755176.png)\n\n\n\n### 我们的优势\n\n肯定有同学要问啦，现在网上的 AI 工具那么多，为什么选择用鱼聪明 AI 呢？\n\n如果你是一个有点儿技术、能摸索的同学，你当然可以自己搞 AI 账号、自己用开源项目搭建；当然，这也意味着你要自己维护和承担账号、服务器费用，注意开源项目中的一些漏洞。\n\n但是，使用鱼聪明 AI， **不需要任何的门槛！也不需要自己搞账号！**\n\n现在 **试运营期间** ，所有用户每天都可以免费领 50 根鱼毛（可用 50 次对话），而且注册就送 50（可以累积）。我们在后台对内测用户做了数据分析，发现对绝大多数同学来说，每日 50 次足够了。\n\n当然，我们的系统背后，也承担了巨量的费用，人力 + 服务器 + AI 服务 + 网安费等等；我们做这款产品，肯定也是 **希望能有收益的** ，总不能让公司破产吧。\n\n所以我们也提供了 **会员服务** ，但我们的优势在于：\n\n1）只有月度会员，不搞年费！不搞终身！ **你需要用的时候开通即可** 。\n\n2）会员的价格 **甚至低于 GPT 官方** ！来算一笔账：19.9 元可以领 3000 根鱼毛，0.006 元每次，一次不足一分！而使用 OpenAI GPT 3.5 模型官方平均 0.014 元一次，**我们比官方还便宜 2 倍** ！\n\n我敢说，这绝对已经非常良心了，我们现在 **每天有上万名用户** ，大家算一算成本就知道了。\n\n目前是试运营阶段，大家感兴趣的话建议赶紧试试，薅一波鱼毛，等后面我们的用户数多了、成本太高的话，我们也可能会调整策略，还请大家理解。\n\n\n\n### 使用方法\n\n在线：https://yucongming.com（手机版也可以使用哦）\n\n百度搜：鱼聪明 AI，第一个就是我们\n\n\n\n---\n\n\n\n最后，感谢我们团队的阿星、松柏、小 y、凯西、yun 姐、鱼皮等人共同完成了这个项目。\n\n之前有同学问我创业做什么？那我必然是想做自己的产品的。不过这个项目也只是一个尝试，不是主打产品哈哈，毕竟 AI 太火了，我们也不得不出手。\n\n感谢大家的支持，有 Bug 也欢迎随时向我们反馈~\n\n如果觉得不错的话，分享给身边需要的朋友吧，这将成为我们不断改进的动力！❤️",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/bo2j3Tim-640.jpg",
        "language": null,
        "viewNum": 183,
        "thumbNum": 6,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-20T12:23:07.000+00:00",
        "updateTime": "2023-07-03T11:04:53.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 1740,
          "coin": 170,
          "followeeNum": 862,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2024-05-24T03:35:38.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-07-03T15:46:55.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1670012971482361858",
        "title": "前端一年半，半年总结",
        "description": "一个努力生活，努力工作的前端开发工程师的半年总结",
        "content": "## 我也想成为 不高兴就喝水口 中的前 10%\n\n ![image-20230617165418569](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617165418569.png)\n\n​\t从我的老板和水哥的聊天中，水哥说了一个很接地气的理论，如果能够成为行业的前 10% ，一定不会太差。我是很认同的，确实不能再每天都当 NPC ，随波逐流了，那行业前10%前提怎么实现呢？从我现在来看我觉得是非常难的，原因有：\n\n1. 我目前的学历和能力都很普通，没有在大厂工作的经历\n2. 社会压力很大，人们都在奋斗，互联网行业也不再像之前那样充满活力\n3. 我常常会被短暂的激情所驱使，情绪容易波动，难以保持专注\n4. 不可否认，现在有很多诱惑，比如抖音等社交媒体，总是把我时间偷走\n5. 也没有什么抱负，没有很强的事业心那种，希望自己能够把生活过的不错就满意了\n\n。。。 总之 ，我就是一个知道很多，但是缺少行动力的人，但是，我身边人都很优秀啊，环境对绝大多数的人的影响都是很大的，我这样认为，我有一个不能再优秀的老板，有每天都打鸡血似的小 y，还有太多优秀的人被我看见，希望自己能平视这些优秀的伙伴，看了很多道理，听了很多故事，我想我需要规划一下自己，彻底的，客观的直视自己，总结一下上半年，规划一下 下半年 和 自己的未来，总不能一直被推着走，\n\n​\t![image-20230617165753688](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617165753688.png)\n\n​\t这是我在年初定的目标，其实是完全没有做到的，但是这半年我也有改变，找到了真正喜欢的工作，真的很幸运，也让我更加相信行动的重要性，我只需要努力去做，结果交给时间。\n\n​\t在上半年，我有段时间是在每天学习的，每天写新的技术笔记，很不幸，和每次都一样，没能坚持，也让我更加坚信，行动是需要动力的，生活是需要鼓励和鸡汤的，\n\n![image-20230617170334695](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617170334695.png)\n\n​\t这是我的 github 近期，语雀也差不多，我考了驾照，成功找到梦想工作，学习了新的技术，做了自己的简单的博客系统，但是还有很多功能需要添加，现在还不能上线，学习了很多技术，也做了自己的技术栈总结，了解自己会哪些，哪些需要系统学习，补充。也有思考过自己的工作和生活的平衡点，还在慢慢探索属于自己的高效工作，快乐生活的方法。\n\n​\t对于 2023 的上半年，我其实摆烂了，没有达到年初的 flag，但是 2023 还在继续，我会在下半年加油⛽️，努力把 flag 都变成现实，我觉得无论是摆烂还是积极努力，都是最好的我，都是为了更好的整理好继续前进。如果你觉得我说的对，那给我点个赞可以吗，这对我真的很重要\n\n​\t进入 2023 年下半年，我将全力以赴工作和生活，减少懒散，多做有意义的事情。以下是我的具体目标：\n\n1. 深入学习React源码，提升技术水平，增强解决问题的能力和从容应对的能力\n2. 写文章，**每周**至少一偏纯技术学习笔记，学习并记录下来，希望通过分享简单易懂的文字，提高自己的写作能力，编程能力和思维能力\n3. **每周**至少运动一次，跑步，羽毛球等等，健康和钱 ，我全都要 \uD83D\uDC36\n4. 努力工作，认真工作，让自己成为一个成熟的打工人，不拖后腿，如果能产生更多价值，那就更好了\n5. 快乐生活，简单大方，希望自己能够落落大方，对待任何事情和人，提高自己情绪的稳定性\n6. 希望能够找到一个合适的伴侣。\n7. 希望自己能开启自己的自媒体的路，其实我也很喜欢分享和开源，所以记录下我的成长不会是我的负担，\n8. 做自己的博客网站，并开源，并写详细的实现过程，做一个自己的原创项目\n9. 我有两个榜样，一个是冴羽，一个是鱼皮，希望能从他们身上学到更多，并将其转化为自己的收获。\n\n​\t这里，我分享一下 冴羽 的微信付费文章，真的不错，是我 2023 前五的对自己的投资，从如何建立信念，培养自尊，刺激去行动，如何更好的去行动，如何寻找目标，如何更好的管理自己的精力，到近期的如何更好的管理自己，每一篇都是精华，给大家看下我的阅读笔记\n\n![image-20230617173923681](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230617173923681.png)\n\n​\t\n\n​\t最后，我自身总结发现，如果想要去做一件事情并且坚持下来，是需要自己给自己的行为赋予意义的，也可以说是自己给自己画饼，只有自己和这个目标产生吸引力，才能产生动力，才能产生行为，才能产生结果。至于是什么结果，我觉得应该不会太差。这也是我最近学习到的 吸引力法则，动力本身就应该源于自己，不是源于我自己的动力产生的行为，在我身上都没有坚持下来，不知道大家是不是这样。\n\n​\t半年总结活动还在进行，希望看到更多人对自己的思考，并分享出来，写下来，大家互相学习，一起进步。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/eXtBPogO-快乐的小狗.png",
        "language": null,
        "viewNum": 109,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-06-17T10:18:14.000+00:00",
        "updateTime": "2023-07-02T14:18:45.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": "https://github.com/chaseFunny",
          "blog": "https://chasefunny.github.io/",
          "score": 0,
          "coin": 0,
          "followeeNum": 11,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-13T14:37:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-07-02T15:18:14.000+00:00"
        },
        "tags": [
          "文章",
          "交流社区",
          "自我介绍",
          "前端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "123",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "13"
  },
  "message": "ok"
}